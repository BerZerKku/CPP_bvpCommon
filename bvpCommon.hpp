/*
 * bvpCommon.hpp
 *
 *  Created on: Aug 20, 2020
 *      Author: bear
 */

#ifndef BVPCOMMON_HPP_
#define BVPCOMMON_HPP_

#include <cstdint>

#ifndef TEST_FRIENDS
#define TEST_FRIENDS
#endif

namespace BVP {

static const uint8_t BVP_STM32_i2c_address  = 0x3D;

/** Пакет для общения STM32 и Raspberry на плате БВП61850.
 *
 *  При приеме пакета от STM32 периодически в первом байте старший бит
 *  принимается 1, вместо 0. Для обхода данной проблемы был добавлен байт
 *  начала пакета.
 *
 *  \todo Периодически на ПК принимается пакет "D5 FF FF ... FF".
 *  Похоже STM32 не получает ACK при передаче байт. Но откуда берется D5?
 */
class BvpPkg {
  TEST_FRIENDS;

  static const uint8_t c_sop;           ///< Значение байта "Начало пакета".
  static const uint8_t c_dataLen = 32;  ///< Количество байт данных в пакете.

  /** Структура пакета.
   *
   *  - Начало пакета: 0xAB
   *  - Номер последовательности: 1 .. 65535
   *    После передачи пакета принятый в ответ пакет должен содержать то же
   *    самое значение номера последовательности. Это считается подтверждением
   *    корректно принятого сообщения на приемной стороне. После этого номер
   *    увеличивается.
   *  - Данные
   *  - Контрольная сумма
   */
  struct __attribute__((packed)) pkg_t {
    uint8_t   sop = 0;                ///< Начало пакета.
    uint16_t  sequence = 0;           ///< Номер последовательности.
    uint8_t   data[c_dataLen] = {0};  ///< Данные.
    uint8_t   checksum = 0;           ///< Контрольная сумма.
  };

public:
  /// Конструктор
  BvpPkg();

  /** Проверяет принятые данные.
   *
   *  @return Результат проверки принятого пакета (true - все в порядке).
   */
  bool checkRx() const;

  /** Возвращает указатель на начало пакета для приема и его размер.
   *
   *  @param[out] buf Буфер.
   *  @return Количество байт.
   */
  uint8_t* getRxPkg(uint16_t &len) const;

  /** Возвращает указатель на начало пакета для передачи и его размер.
   *
   *  @param[out] buf Буфер.
   *  @return Количество байт.
   */
  uint8_t* getTxPkg(uint16_t &len)  const;

  /// Подготовка пакета для передачи.
  void prepareTx();

private:
  pkg_t pkgRx;  ///< Пакет для приема.
  pkg_t pkgTx;  ///< Пакет для передачи.

  /** Вычисляет контрольную сумму для пакета.
   *
   *  @param[in] pkg Пакет.
   *  @return Контрольная сумма.
   */
  uint8_t getChecksum(const pkg_t &pkg) const;

  /** Вычисляет 8-битную контрольную сумму для массива 8-битных данных.
   *
   *  Алгоритм подсчета используемый в Авант:
   *    младший байт суммы всех байт данных.
   *
   *  @param[in] buf Массив 8-битных данных.
   *  @param[in] len  Количество данных.
   *  @return 8-битная контрольная сумма.
   */
  uint8_t calcChecksumAvant(const uint8_t buf[], uint16_t len) const;

  /** Вычисляет 8-битную контрольную сумму для массива 8-битных данных.
   *
   *  Алгоритм подсчета дополнение до 0:
   *    сумма всех байт с учетом контрольной суммы должна равняться 0.
   *
   *  @param[in] buf Массив 8-битных данных.
   *  @param[in] len  Количество данных.
   *  @return 8-битная контрольная сумма.
   */
  uint8_t calcChecksumCompl0(const uint8_t buf[], uint16_t len) const;

  /** Вычисляет 8-битную контрольную сумму для массива 8-битных данных.
   *
   *  Алгоритм подсчета взят из статьи https://habr.com/ru/post/278171/.
   *
   *  Добавлено начальное состояние 0xABBA, иначе для последовательности нулей
   *  была корректная контрольная сумма.
   *
   *  @param[in] buf Массив 8-битных данных.
   *  @param[in] len  Количество данных.
   *  @return 8-битная контрольная сумма.
   */
  uint8_t calcChecksumHabr(const uint8_t buf[], uint16_t len) const;

  /** Проверяет контрольную сумму пакета.
   *
   *  @param[in] pkg Пакет.
   *  @return true если верная контрольная сумма, иначе false.
   */
  bool isChecksum(const pkg_t &pkg) const;

  /** Изменяет счетчик последовательности.
   *
   *  Увеличивает счетчик последовательности на 1.
   *  Если счетчик переполнен и значение устанавливается в 0, оно изменяется
   *  на 1.
   *
   *  @param[in] sequence Текущее значение счетчика последовательности.
   *  @return Новое значение счетчика последовательности (1 .. 65535).
   */
  uint16_t sequenceModify(uint16_t sequence);
};

} /* namespace BVP */

#endif /* BVPCOMMON_HPP_ */
